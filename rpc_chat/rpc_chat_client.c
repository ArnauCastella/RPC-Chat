/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <pthread.h>
#include <ncurses.h>

#include "rpc_chat.h"

#define MAX_USERNAME_SIZE 	100
#define INPUT_WINDOW_ROWS 	1
#define MAX_MSG_SIZE 		100

typedef struct {
    	WINDOW *outputWindow;
    	WINDOW *inputWindow;
    	CLIENT *clnt;
    	char username[MAX_USERNAME_SIZE];
} ChatClient;

void rpcchatprog_1(char *host, char *username);
void startUI(ChatClient *client);
void closeUI(ChatClient *client);
void startChat(ChatClient *client);
void handleInput (ChatClient *client, int ch, char *buf);
void *printChat (void *vargp);

int main (int argc, char *argv[]) {
	char *host = argv[1];

	if (argc < 3) {
		printf ("usage: %s server_host username\n", argv[0]);
		exit (1);
	}
	
	// Call the function generated by rpcgen
 	rpcchatprog_1 (host, argv[2]);
	exit (0);
}

void rpcchatprog_1(char *host, char *username) {
	ChatClient client;

#ifndef	DEBUG
	client.clnt = clnt_create (host, RPCCHATPROG, RPCCHATVERS, "udp");
	if (client.clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	strncpy(client.username, username, MAX_USERNAME_SIZE);

	startUI(&client);
	startChat(&client);
	closeUI(&client);
	
#ifndef	DEBUG
	clnt_destroy (client.clnt);
#endif	 /* DEBUG */
}

void startUI (ChatClient *client) {
	
	// Two separate screens for the chat and the input
	// One row separation between screens
	
	int height, width;
	
	initscr();
	getmaxyx(stdscr, height, width);
	client->inputWindow = newwin(INPUT_WINDOW_ROWS, width, height - INPUT_WINDOW_ROWS, 0);
	client->outputWindow = newwin(height - (INPUT_WINDOW_ROWS + 1), width, 0, 0);	
}

void closeUI (ChatClient *client) {
	delwin(client->inputWindow);
	delwin(client->outputWindow);
	endwin();
}

void startChat (ChatClient *client) {
	// Start thread to refresh the displayed chat every second
	pthread_t printChatThread;
	pthread_create(&printChatThread, NULL, printChat, (void *)client);
	
	int ch;
	char buf[MAX_MSG_SIZE] = {0};
	
	// Handle input of the user
	// Exits when the key ESC is pressed
	while ((ch = getch()) != '\033') {
		handleInput(client, ch, buf);
		werase(client->inputWindow);
		wprintw(client->inputWindow, "%s: %s", client->username, buf);
		wrefresh(client->inputWindow);
	}
}

void handleInput (ChatClient *client, int ch, char *buf) {
	switch(ch) {
		case '\n':
			// Store the message in the server
						
			int size = snprintf(NULL, 0, "%s: %s\n", client->username, buf);
			char *formatMsg = malloc(size + 1);
			snprintf(formatMsg, size + 1, "%s: %s\n", client->username, buf);
			int *result = write_1(&formatMsg, client->clnt);
			if (!*result) {
				clnt_perror(client->clnt, "write call failed");
			}
			buf[0] = '\0';
			free(formatMsg);
			break;			
		
		case KEY_BACKSPACE:
		case 127:
		case '\b':
			// Delete last character
			if (strlen(buf) > 0) {
				buf[strlen(buf) - 1] = '\0';
			}
			break;
			
		default:
			// Store the character
			int aux = strlen(buf);
			if (aux+2 < MAX_MSG_SIZE) {
				buf[aux] = ch;
				buf[aux+1] = '\0';
			}
	}
}

void *printChat (void *vargp) {
	ChatClient *client = (ChatClient *)vargp;
	
	while (1) {
		// Retrieve entire chat from server
		char *aux;
		char **result = getchat_1((void*)&aux, client->clnt);
		// Display it on screen
		werase(client->outputWindow);
		mvwprintw(client->outputWindow, 0, 0, "%s", *result);
		wrefresh(client->outputWindow);
		sleep(1);
	}
}



